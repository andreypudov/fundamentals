<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fundamentals.Sorting</name>
    </assembly>
    <members>
        <member name="T:Fundamentals.Sorting.BubbleSort">
            <summary>
            Bubble sort, sometimes referred to as sinking sort, is a simple
            sorting algorithm that repeatedly steps through the list, compares
            adjacent elements and swaps them if they are in the wrong order.
            The pass through the list is repeated until the list is sorted.
            The algorithm, which is a comparison sort, is named for the way
            smaller or larger elements "bubble" to the top of the list.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.BubbleSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.BubbleSortWithFlag">
             <summary>
             Bubble sort, sometimes referred to as sinking sort, is a simple
             sorting algorithm that repeatedly steps through the list, compares
             adjacent elements and swaps them if they are in the wrong order.
             The pass through the list is repeated until the list is sorted.
             The algorithm, which is a comparison sort, is named for the way
             smaller or larger elements "bubble" to the top of the list.
            
             The implementation introduces a flag variable to stop the bubble sort
             as soon as it becomes sorted.
             </summary>
        </member>
        <member name="M:Fundamentals.Sorting.BubbleSortWithFlag.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.HeapSort">
            <summary>
            Heapsort is a comparison-based sorting algorithm. Heapsort can be
            thought of as an improved selection sort: like selection sort,
            heapsort divides its input into a sorted and an unsorted region, and
            it iteratively shrinks the unsorted region by extracting the largest
            element from it and inserting it into the sorted region. Unlike
            selection sort, heapsort does not waste time with a linear-time scan
            of the unsorted region; rather, heap sort maintains the unsorted
            region in a heap data structure to more quickly find the largest
            element in each step.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.HeapSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.InsertionSort">
            <summary>
            Insertion sort is a simple sorting algorithm that builds the final
            sorted array (or list) one item at a time. It is much less efficient
            on large lists than more advanced algorithms such as quicksort,
            heapsort, or merge sort.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.InsertionSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.IntExtensions">
            <summary>
            Provides extension methods for integer type.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.IntExtensions.Shift(System.Int32,System.Int32)">
            <summary>
            Unsigned right shift.
            </summary>
            <param name="value">The original integer value.</param>
            <param name="digits">The number of digits to shoft.</param>
            <returns>The value with number of digits shifted right.</returns>
        </member>
        <member name="T:Fundamentals.Sorting.ISort">
            <summary>
            Exposes a method that sorts the elements in a one-dimensional array.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.ISort.Sort``1(``0[])">
            <summary>
            Sorts the elements in an entire <see cref="T:System.Array"/> using the <see cref="T:System.IComparable`1"/>
            generic interface implementation of each element of the Array.
            </summary>
            <typeparam name="T">The type of the elements in the array.</typeparam>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array"/> to sort.</param>
            <exception cref="T:System.ArgumentNullException"><c>array</c> is <c>null</c>.</exception>
            <exception cref="T:System.InvalidOperationException">One or more elements in <c>array</c> do not implement the <see cref="T:System.IComparable`1"/> generic interface.</exception>
        </member>
        <member name="T:Fundamentals.Sorting.MergeSort">
            <summary>
            In computer science, merge sort (also commonly spelled mergesort) is
            an efficient, general-purpose, comparison-based sorting algorithm.
            Most implementations produce a stable sort, which means that the order
            of equal elements is the same in the input and output. Merge sort is
            a divide and conquer algorithm that was invented by John von Neumann
            in 1945. A detailed description and analysis of bottom-up mergesort
            appeared in a report by Goldstine and von Neumann as early as 1948.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.MergeSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.QuickSort">
            <summary>
            Quicksort is a divide-and-conquer algorithm. It works by selecting
            a 'pivot' element from the array and partitioning the other elements
            into two sub-arrays, according to whether they are less than or
            greater than the pivot. The sub-arrays are then sorted recursively.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.QuickSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.QuickSortAsync">
            <summary>
            Quicksort is a divide-and-conquer algorithm. It works by selecting
            a 'pivot' element from the array and partitioning the other elements
            into two sub-arrays, according to whether they are less than or
            greater than the pivot. The sub-arrays are then sorted recursively.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.QuickSortAsync.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.QuickSortDualPivot">
            <summary>
            Quicksort is a divide-and-conquer algorithm. It works by selecting
            a 'pivot' element from the array and partitioning the other elements
            into two sub-arrays, according to whether they are less than or
            greater than the pivot. The sub-arrays are then sorted recursively.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.QuickSortDualPivot.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.QuickSortDualPivotParallel">
            <summary>
            Quicksort is a divide-and-conquer algorithm. It works by selecting
            a 'pivot' element from the array and partitioning the other elements
            into two sub-arrays, according to whether they are less than or
            greater than the pivot. The sub-arrays are then sorted recursively.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.QuickSortDualPivotParallel.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.QuickSortParallel">
            <summary>
            Quicksort is a divide-and-conquer algorithm. It works by selecting
            a 'pivot' element from the array and partitioning the other elements
            into two sub-arrays, according to whether they are less than or
            greater than the pivot. The sub-arrays are then sorted recursively.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.QuickSortParallel.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.RadixSort">
            <summary>
            Radix sort is a non-comparative sorting algorithm. It avoids
            comparison by creating and distributing elements into buckets
            according to their radix.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.RadixSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.SelectionSort">
            <summary>
            Selection sort is an in-place comparison sorting algorithm. It has
            an O(n2) time complexity, which makes it inefficient on large lists,
            and generally performs worse than the similar insertion sort.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.SelectionSort.Sort``1(``0[])">
            <inheritdoc />
        </member>
        <member name="T:Fundamentals.Sorting.SystemArraySort">
            <summary>
            Represents a <see cref="M:System.Array.Sort``1(``0[])"/> implementation.
            </summary>
        </member>
        <member name="M:Fundamentals.Sorting.SystemArraySort.Sort``1(``0[])">
            <inheritdoc />
        </member>
    </members>
</doc>
